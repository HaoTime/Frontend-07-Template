## :pushpin:学习笔记

>编译原理要抽时间学习一下啦:dizzy_face:

### 1.AST

#### 1.1.What?

AST 叫做抽象语法树，是用编程语言编写的源代码的抽象语法结构的树状表现形式，树的每个节点表示在源代码中出现的构造；  
这里的语法是 `抽象` 的，并不会表示出真实语法中出现的每个细节，只是结构、内容的相关细节；  
语法树通常由 `解析器 Parser` 在源代码转换和编译过程中构建，一旦构建，通过后续处理（如：上下文分析）将附加信息添加到AST。  
  
javaScript Parser 是把js源码转化为抽象语法树的解析器，一般分为词法分析、语法分析以及代码生成或执行
![parser](https://haotime.oss-cn-hangzhou.aliyuncs.com/Frontend-07-Template/parser.png)
- 词法分析，也叫扫描scanner
  词法解析代码的时候，是一个个字母读取，遇到空格、操作符或者特殊字符的时候，会认为一个话已经完成了读取代码，并且移除空白符、注释等，将整个代码分割进一个tokens列表（一维数组）。
- 语法分析，构建AST的过程
  将词法解析生成出来的tokens列表生成树形的表达形式，同时验证语法错误，错误的话就抛出错误；在生成树的过程中，解析器会删除一些没必要的tokens（比如不完整的括号）

#### 1.2.Why?

简单说，就是编程语言太多，需要一套统一的结构让计算机识别  
抽象语法树的特点：不依赖具体的文法、不依赖语言的细节

>当源程序语法分析工作时，是在相应程序设计语言的语法规则指导下进行的；  
>语法规则描述了该语言的各种语法成分的组成结构；  
>通常可以用所谓的 `上下文无关文法` 或与之等价的 `Backus-Naur范式（BNF）` 将一个程序设计语言的语法规则确切的描述出来；  
>上下无关文法有 LL(1)、LR(0)、LR(1)、LR(k)、LALR(1) 等几类，每种的文法都有不同的要求；  
>  
>开发语言时，一开始可能选择LL(1)文法描述语言的语法规则，编译器前端生成LL(1)语法树，编译器后端对LL(1)语法树进行处理，生成字节码或者汇编语言；  
>但随着工程的开发，在语言中加入了更多的特性，这时用LL(1)文法描述时，感觉限制很大，并且编写文法时很吃力；  
>决定换用LR(1)文法，如果这时候把编译器前端改成LR(1)语法树，编译器后端不得不也要修改；
>  
>这时就是体现出 抽象语法树 的优点，不论是LL(1)，还是LR(1)，都要求在语法分析时，构造出相同的语法树

#### 1.3.How?

>抽象语法树，可用于语法检查、编译、代码高亮、代码转换、优化、压缩等等场景  
>Babel、Webpack、Lint等工具的核心都是通过抽象语法树实现的，实现对代码的检查、分析

### 2.上下文无关文法

>上下文无关文法描述了一列形式语言，用来描述计算机语言语法的符号集

上下文无关文法就是说这个文法中 **所有的产生式左边只有一个非终结符**  
比如：  
```javascript
S -> aSb
S -> ab
```
这就是上下文无关文法，这个文法有两个产生式，每个产生式左边都有一个非终结符S，因为只要找到符合产生式右边的串，就可以把它规约为对应的非终结符

比如：
```javascript
aSb -> aaSbb
S -> ab
```
这就是上下文相关文法，因为他的第一产生式左边有不止一个符号，所以你在匹配这个产生式中的S的时候必须确保这个S有正确的`上下文`，也就是确保左边的a和右边的b.
  
### 3.BNF范式

巴科斯诺尔范式（Backus Normal Form）  
一种用于表示上下文无关文法的语言  
一种用递归的思想来表述计算机语言符号集的定义规范  
  
BNF规定是推导规则（产生式）的集合  
基本结构：

<符号> ::= <使用符号的表达式>
 
`符号` 是非终结符，而 `表达式` 由一个符号序列，或用指示选择的竖线 '|' 分隔的多个符号序列构成  
每个符号序列整体都是左端的符号的一种可能的替代  
从未在左端出现的符号叫做 `终结符`  
通俗来说，`表达式` 进一步解释、定义 `符号`  

语法：
  - ::= 表示 定义
  - "" 双引号里内容表示 字符，双引号外内容表示 语法部分
  - <> 尖括号里的内容表示 必选项
  - [] 方括号里的内容表示 可选项
  - {} 大括号里的内容表示 可重复0至无数次的项
  - | 竖线两边的是可选内容，相当于or

终结符：
  - Number
  - + - * /

非终结符：
  - MultiplicativeExpression
  - AdditiveExpression 

产生式：  
在计算机中指编译器将源程序经过词法分析和语法分析后得到的一系列符合文法规则（BNF）的语句，即推导规则  

举例：
```javascript
<Hao> ::= <程序员> | <阳光宅男> | <修仙选手>
<Number> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "9"
```
  
### 4.语法分析算法

两种核心思想
- LL算法：从左到右扫描，从左到右规约
- LR算法

#### 4.1.四则运算 - 词法定义
- TokenNmber：
  - 1 2 3 4 5 6 7 8 9 0 的组合
  - 允许在中间插入小数点
- Operator：+、-、*、/ 之一
- Whitespace：<SP> //空格
- LineTerminator：<LF> <CR> //行终止符
  
#### 4.2.四则运算 - 语法定义
```javascript
<Expression>::=
  <AdditiveExpression><EOF>

<AdditiveExpression>::=
  <MultiplicativeExpression>
  |<AdditiveExpression><+><AdditiveExpression>
  |<AdditiveExpression><-><AdditiveExpression>

<MultiplicativeExpression>::=
  <Number>
  |<MultiplicativeExpression><*><Number>
  |<MultiplicativeExpression></><Number>
```

### 5.正则表示式

exec() 方法用于检索字符串中的正则表达式的匹配

  
## :trophy:学习总结

本周主要学习内容 编译原理 中字符串处理：`使用LL算法构建AST`

涉及 编译原理内容、词法分析、语法分析、正则表达式 等

- [ ] 编译原理
- [ ] 词法分析
- [ ] 语法分析
- [ ] 正则表达式
  
  
## :sunflower:资料参考

- <a href="https://blog.csdn.net/weixin_39408343/article/details/95984062">AST(抽象语法树)超详细 - CSDN</a>
- <a href="https://www.zhihu.com/question/21833944">应该如何理解「上下文无关文法」？ - 知乎</a>
- <a href="https://bk.tw.lvfukeji.com/baike-%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">巴科斯范式 - 中文维基百科</a>
- <a href="https://juejin.cn/post/6877043337262694408">BNF范式（巴科斯范式）到底是什么？- 掘金</a>
- <a href="https://time.geekbang.org/column/article/868235">（小实验）理解编译原理：一个四则运算的解释器 - 极客时间</a>
  
  
## :gift_heart:学习交流

![Hao](https://haoer.oss-cn-hangzhou.aliyuncs.com/hao.jpg)

欢迎大家加微信交流 Thanksヾ(✿ﾟ▽ﾟ)ノ
  
  